---
layout: post
title: Java核心技术--继承
categories: [Java]
description: Java核心技术总结
keywords: Java, 继承
---

### 5.1 超类继承
#### 1. super的用法
在使用超类的构造器时，可以用super(param1, param2, ...); 当在子类中重写超类的方法时，又调用了超类的同名方法，为避免方法名解析歧义，需用super.func()
```
编译package中的java文件时，有时会报类似无法引用package类的错误
解决方法：cd到package外的基目录，再进行javac编译即可
```

#### 2. 动态绑定
+ **重载解析**  编译器在执行x.f(param)时，如果所有名f的方法中有一个与提供的参数类型完全匹配，就选择这个方法。否则报错。
```
方法的名字和参数列表称为方法的签名。如f(int) 和 f(String)方法名相同，但签名不同
```
+ **静态绑定** 如果是private方法、static方法、final方法或者换构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式为静态绑定。
+ 当程序运行，并采用动态绑定时，JVM一定调用与x所引用对象的**实际类型**最合适的那个类方法。
```
假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；
否则，将在D类的超类中寻找f(String)，以此类推
```
#### 3.阻止继承：final类和方法
+ 如果不希望某个类被继承，即不允许被扩展，称为final类，使用final修饰符声明
+ 类中的方法被声明为final时，子类就不能覆盖这个方法 (**final类中所有方法自动称为final方法**)
+ final类中域并不会自动声明为final域，这与final方法有别。
+ **内联** 如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联。
### 5.2 抽象类
#### 1. abstract修饰符
包含一个或多个抽象方法的类本身必须被声明为抽象的
```java
abstract class Person
{
	public abstract String getDescription();
}
```
抽象类可以包含具体的数据和具体方法。但许多程序员认为，在抽象类中不能包含具体的方法，建议尽量将通用的域和方法放在超类中。
+ 类即使不含抽象方法，也可以声明为抽象类
+ 抽象类不能被实例化，但可以创建一个具体子类的对象
```
Person p = new Student(“Kevin”, “CS”);
```
P是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例
### 受保护访问
#### 1. protected 修饰符
允许超类的某些方法被子类访问，或允许子类的方法访问超类的某个域
#### 2. 不建议对域使用protected，受保护方法更具有实际意义
+ 仅对本类可见——private
+ 对所有类可见——public
+ 对本包和所有子类可见——protected
+ 对本包可见——默认（很遗憾）， 不需要修饰符

### equals方法
```java
public boolean equals(Object otherObject)
    {
	// a quick test to see if the object are identical
        if (this == otherObject) return true;

	// must return false if the explicit parameter is null
        if (otherObject == null) return false;

	// if classes doesn’t match, they can’t be equal
        if (getClass() != otherObject.getClass())
            return false;

        Employee other = (Employee) otherObject;
	// test whether the fields have identical values
        return Object.equals(this.name, other.name)
            && this.salary == other.salary
            && Object.equals(this.hireDay, other.hireDay);
    }
```
不建议使用instanceof方法，因为没有考虑到otherObject是子类的情况。
Java语言规范要求equals方法具有以下的特性：
+ **自反性** x.equals(x) == true
+ **对称性** y.equals(x) == x.equals(y)
+ **一致性** 反复调用x.equals(y)结果应该一致
+ **对于非空引用x**，x.equals(null) == false

换个角度
+ 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测
+ 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等比较

#### 下面给出编写一个完美 equals 方法的建议
1. 显式参数命名为otherObject，稍后需要将它转换为另一个叫做other的变量
2. 检测 this 与 otherObject是否引用同一个对象
```
if (this == otherObject) return true;
```
3. 检测 otherObject 是否为null，如果为null，返回false，很有必要
```
if (otherObject == null) return false;
```
4. 比较this与otherObject是否属于同一类。如果equals的语义在每一个子类中有所改变，就用getClass检测
```
if (getClass() != otherObject.getClass()) return false;
```
5. 将otherObject转换为相应的类型变量
```
ClassName other = (ClassName) otherObject;
```
6. 对比所有的域。使用 == 比较基本类型域，使用equals比较对象域。**如果在子类中重新定义equals，就要在其中包含调用super.equals(other)**

### hashCode()方法
Object.hashCode(param) —— 如果参数为null，返回0，否则返回对参数调用hashCode的结果
### toString() 方法
只要对象与一个字符串通过操作符 ”+“ 连接起来，java编译就会自动调用toString()方法。
Arrays.toString() 和 Arrays.deepToString()

### 5.3 泛型数组
动态确定数组的大小
```
ArrayList<Employee> staff = new ArrayList<Employee>();
或者省略后面的类型参数
ArrayList<Employee> staff = new ArrayList<>();
```
#### 访问数组列表元素
自动扩展容量的便利增加了访问元素语法的复杂程度。使用get和set实现访问和改变元素，而非 [] 语法格式

### 5.4 自动装箱
#### 包装器
所有的基本类型都有一个与之对应的类，如Integer类对应基本类型int，成为包装器。对象包装器类还是final，因此不能定义它们的子类。
```
ArrayList<Integer> list = new ArrayList<>();
```
#### 自动装箱
Java SE 5.0之后，调用 list.add(3) 将自动变成 list.add(Integer.valueOf(3))，这种变换称为自动装箱(autoboxing)
```
Integer n = 3;
n ++; // 自动插入一条对象拆箱的指令，然后自增计算，最后再将结果进行装箱
```
+ **在两个包装器对象比较时，调用equals方法，而不建议使用 ==**
+ 装箱和拆箱是**编译器认可的**，而非虚拟机

### 5.5 参数数量可变的方法
... —— 是代码的一部分
```
public static double max(double... values)
{
	double largest = Double.MIN_VALUE;
	for (double v : values) if (v > largest) largest = v;
	return largest;
}
```

### 5.6 枚举类
```
public enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE}
```
+ 比较两个枚举类型的值时，永远不需要调用equals，直接使用 == 就可以
+ 可以在枚举类型中添加一些构造器、方法和域。所有的枚举类都是Enum的子类，继承了包括toString等许多方法

```
Size.SMALL.toString();   // “SMALL”
Size s = Enum.valueOf(size.class, “SMALL”); // s设置为Size.SMALL
Size[] values = Size.values(); //返回Size的数组
```

### 5.7 反射
能够分析类能力的程序称为**反射**。
+ 在运行中分析类的能力
+ 在运行中查看对象，例如，编写一个toString方法供所有类使用
+ 实现通用的数组操作代码
+ 利用Method对象，这个对象很像C++中的函数指针
**待补充**
