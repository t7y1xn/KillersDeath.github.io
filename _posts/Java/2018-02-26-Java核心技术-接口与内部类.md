---
layout: post
title: Java核心技术--接口与内部类
categories: [Java]
description: Java核心技术总结
keywords: Java, 接口, 内部类
---

### 6.1 接口implement
继承接口，即履行“义务”
+ 接口中所有的方法自动属于public，在接口声明中，不必提供关键字public
+ **接口中决不能含有实例域，也不能在接口中实现方法**
为了让类实现一个接口，通常需要下面两个步骤：
1. 将类声明为实现给定的接口
2. 对接口中的所有方法进行定义

#### 接口与抽象类
为什么要引入接口，抽象类不是已经满足接口的功能了吗？
> **因为每个类只能扩展一个类，Java不支持`多类继承`**，主要原因是多类继承会让语言本身变得非常复杂(如同C++)，效率也会降低(如同Eiffel)。

> 实际上，接口可以提供多重继承的大多数好处，同时还可以避免多重继承的复杂性和低效性。

### 6.2 对象克隆
#### 拷贝
Copy时，原始变量A与copy变量B引用同一个对象，B改变，A也会相应的改变 。
#### 克隆
+ `clone`是Object类的一个`protected`方法，在用户编写的代码中不能直接调用。
+ 默认的`clone`方法是**浅copy**，数值或基本类没有问题，对于子对象的引用，拷贝的结果会使得两个域引用同一个对象。
+ **所有数组类型均包含一个clone方法，public而不是protected**

常常需要重新定义`clone`方法，对每个类需要做以下判断：
1.  默认的clone方法是否满足需求
2. 默认的clone方法是否能够通过调用可变子对象的clone得到修补
3. 是否不应该使用clone

实际上，选项3是默认的。如果选择1或者2，类必须：
1. 实现`Cloneable`接口( 是Java提供的几种标记接口之一，标记接口没有方法)
2. 实现`public`访问修饰符重新定义的clone方法

``` java
Class Employee implements Cloneable
{
	// 即使默认clone能够满足需求，也建议实现Cloneable接口
	public Employee clone() throws CloneNoSupportedException
	{
		// call Object clone()
		Employee cloned = (Employee) super.clone();
		// clone mutable fields
		cloned.hireDay = (Date) hireDay.clone();
		return cloned;
	}
}
```

### 6.3 接口与回调(callback)
```java
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;
public class TimerTest
{
    public static void main(String[] args)
    {
        ActionListener listener = new TimePrinter();
        Timer t = new Timer(1000, listener);
        t.start();

        JOptionPane.showMessageDialog(null, "quit program");
        System.exit(0);
    }
}

class TimePrinter implements ActionListener
{
    public void actionPerformed(ActionEvent event)
    {
        Date now = new Date();
        System.out.println("At the tone, the time is" + now);
        Toolkit.getDefaultToolkit().beep();
    }
}
```

### 6.4 内部类
> 为什么要使用内部类？

+ 内部类可以访问该类定义所在的作用域中的数据，包括**私有数据**
+ 内部类可以对同一个包中其他类隐藏起来
+ **当想定义一个回调函数且不想编写大量的代码时**，使用`匿名内部类`比较便捷
+ 只有内部类可以是私有类，常规类只具有包可见性，或者共有可见性

#### 局部内部类
> 局部类不能用public或者private访问修饰符进行说明。它的作用域被限定在声明在这个局部类的快中。

#### 由外部方法访问final变量
> 局部类还有一个优点，不仅能够访问包含它们的外部类，还可以访问局部变量，不过这些局部变量必须被声明为`final`

``` java
public void start(int interval, final boolean beep)
{
class TimerPrinter implements ActionListener
    {
        public void actionPerformed(ActionEvent event)
        {
            Date now = new Date();
            System.out.println("At the time is " + now);
            if(beep) Toolkit.getDefaultToolkit().beep();
        }
    }
ActionListener listener = new TimerPrinter();
Timer t = new Timer(interval, listener);
t.start();
}
```
